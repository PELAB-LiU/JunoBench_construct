{
  "executed": [
    {
      "execution_count": 1,
      "code_cell_id": 0,
      "code": "import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport torch\nimport torch.nn as nn\nimport torchvision\nimport torchvision.transforms as transforms\nimport cv2\nimport torch.nn.functional as F\nfrom PIL import Image\nfrom glob import glob\nfrom tqdm import tqdm\nfrom itertools import combinations\nfrom torch.utils.data import DataLoader\nfrom torch.utils.data import Dataset"
    },
    {
      "execution_count": 2,
      "code_cell_id": 1,
      "code": "train_images_path = \"data/archive/images_labeled/\""
    },
    {
      "execution_count": 3,
      "code_cell_id": 2,
      "code": "IMAGE_WIDTH = 60\nIMAGE_HEIGHT = 160\nsize = (IMAGE_HEIGHT, IMAGE_WIDTH)"
    },
    {
      "execution_count": 4,
      "code_cell_id": 3,
      "code": "class CustomDataset(Dataset):\n def __init__(self, data, path, transform=None):\n self.data = data\n self.path = path\n self.transform = transform\n\n def __len__(self):\n return len(self.data)\n\n def __getitem__(self, idx):\n img1 = Image.open(train_images_path + self.data[\"image1\"][idx])\n img2 = Image.open(train_images_path + self.data[\"image2\"][idx])\n label = self.data[\"label\"][idx]\n\n if self.transform is not None:\n img1 = self.transform(img1)\n img2 = self.transform(img2)\n\n return img1, img2, label"
    },
    {
      "execution_count": 8,
      "code_cell_id": 4,
      "code": "train_data = pd.read_csv(\"data/pairs.csv\")\nresize = transform=transforms.Compose([transforms.Resize(size),\n transforms.ToTensor()\n ])\ntrain_dataset = CustomDataset(train_data, train_images_path, transform=resize)"
    },
    {
      "execution_count": 9,
      "code_cell_id": 5,
      "code": "def visualize_pair(img1, img2, label):\n fig, axes = plt.subplots(1,2)\n axes[0].imshow(np.transpose(img1.numpy(), (1, 2, 0)))\n axes[1].imshow(np.transpose(img2.numpy(), (1, 2, 0)))\n if label:\n fig.suptitle('Same', y=1)\n else:\n fig.suptitle('Different', y=1)"
    },
    {
      "execution_count": 10,
      "code_cell_id": 6,
      "code": "img1, img2, label = train_dataset[200]\nvisualize_pair(img1, img2, label)"
    },
    {
      "execution_count": 11,
      "code_cell_id": 7,
      "code": "img1, img2, label = train_dataset[50000]\nvisualize_pair(img1, img2, label)"
    },
    {
      "execution_count": 13,
      "code_cell_id": 9,
      "code": "batch_size=64\ntrain_dataloader = DataLoader(train_dataset, shuffle=True, batch_size=batch_size)"
    },
    {
      "execution_count": 15,
      "code_cell_id": 11,
      "code": "class SiameseDataset(Dataset):\n def __init__(self,training_csv,training_dir,transform=None):\n\n self.train_df=pd.read_csv(training_csv)\n self.train_df = self.train_df.drop(columns=['Unnamed: 0'])\n self.train_df.columns =[\"image1\",\"image2\",\"label\"]\n self.train_dir = training_dir\n self.transform = transform\n\n def __getitem__(self,index):\n\n image1_path=os.path.join(self.train_dir,self.train_df.iat[index,0])\n image2_path=os.path.join(self.train_dir,self.train_df.iat[index,1])\n\n img0 = Image.open(image1_path)\n img1 = Image.open(image2_path)\n img0 = img0.convert(\"L\")\n img1 = img1.convert(\"L\")\n\n if self.transform is not None:\n img0 = self.transform(img0)\n img1 = self.transform(img1)\n return img0, img1 , th.from_numpy(np.array([int(self.train_df.iat[index,2])],dtype=np.float32))\n def __len__(self):\n return len(self.train_df)"
    },
    {
      "execution_count": 16,
      "code_cell_id": 12,
      "code": "training_csv=\"data/pairs.csv\"\ntraining_dir=\"data/archive/images_labeled/\"\nresize = transform=transforms.Compose([transforms.Resize(size),\n transforms.ToTensor()\n ])\nsiamese_dataset = SiameseDataset(training_csv, training_dir, transform=resize)"
    },
    {
      "execution_count": 28,
      "code_cell_id": 13,
      "code": "class SiameseNetwork(nn.Module):\n def __init__(self):\n super(SiameseNetwork, self).__init__()\n\n self.cnn1 = nn.Sequential(\n nn.Conv2d(3, 96, kernel_size=5,stride=1),\n nn.ReLU(inplace=True),\n nn.LocalResponseNorm(5,alpha=0.0001,beta=0.75,k=2),\n nn.MaxPool2d(3, stride=2),\n\n nn.Conv2d(96, 256, kernel_size=5,stride=1,padding=2),\n nn.ReLU(inplace=True),\n nn.LocalResponseNorm(5,alpha=0.0001,beta=0.75,k=2),\n nn.MaxPool2d(3, stride=2),\n nn.Dropout2d(p=0.3),\n\n nn.Conv2d(256,384 , kernel_size=3,stride=1,padding=1),\n nn.ReLU(inplace=True),\n\n nn.Conv2d(384,256 , kernel_size=3,stride=1,padding=1),\n nn.ReLU(inplace=True),\n nn.MaxPool2d(3, stride=2),\n nn.Dropout2d(p=0.3),\n )\n\n self.fc1 = nn.Sequential(\n nn.Linear(4500, 500),\n nn.ReLU(inplace=True),\n nn.Dropout2d(p=0.5),\n\n nn.Linear(1024, 128),\n nn.ReLU(inplace=True),\n\n nn.Linear(128,2))\n\n def forward_once(self, x):\n\n output = self.cnn1(x)\n output = output.view(output.size()[0], -1)\n output = self.fc1(output)\n return output\n\n def forward(self, input1, input2):\n\n output1 = self.forward_once(input1)\n\n output2 = self.forward_once(input2)\n return output1, output2"
    },
    {
      "execution_count": 29,
      "code_cell_id": 14,
      "code": "class ContrastiveLoss(torch.nn.Module):\n \"\"\"\n Contrastive loss function.\n Based on:\n \"\"\"\n\n def __init__(self, margin=1.0):\n super(ContrastiveLoss, self).__init__()\n self.margin = margin\n\n def forward(self, x0, x1, y):\n\n diff = x0 - x1\n dist_sq = torch.sum(torch.pow(diff, 2), 1)\n dist = torch.sqrt(dist_sq)\n\n mdist = self.margin - dist\n dist = torch.clamp(mdist, min=0.0)\n loss = y * dist_sq + (1 - y) * torch.pow(dist, 2)\n loss = torch.sum(loss) / 2.0 / x0.size()[0]\n return loss"
    }
  ],
  "target": {
    "code_cell_id": 15,
    "code": "net = SiameseNetwork()\n\ncriterion = ContrastiveLoss()\n\noptimizer = torch.optim.Adam(net.parameters(), lr=1e-3, weight_decay=0.0005)\n\ndef train():\n epochs=100\n loss=[]\n counter=[]\n iteration_number = 0\n for epoch in range(1,epochs):\n for i, data in enumerate(train_dataloader,0):\n img0, img1 , label = data\n\n optimizer.zero_grad()\n output1,output2 = net(img0,img1)\n loss_contrastive = criterion(output1,output2,label)\n loss_contrastive.backward()\n optimizer.step()\n print(\"Epoch {}\\n Current loss {}\\n\".format(epoch,loss_contrastive.item()))\n iteration_number += 10\n counter.append(iteration_number)\n loss.append(loss_contrastive.item())\n show_plot(counter, loss)\n return net\n\ndevice = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\nmodel = train()\ntorch.save(model.state_dict(), \"model.pt\")\nprint(\"Model Saved Successfully\")"
  }
}