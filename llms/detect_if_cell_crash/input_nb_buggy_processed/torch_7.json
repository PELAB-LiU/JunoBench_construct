{
  "executed": [
    {
      "execution_count": 1,
      "code_cell_id": 12,
      "code": "import warnings\nfrom collections import namedtuple\nfrom functools import partial\nfrom typing import Any, Callable, List, Optional, Tuple\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torch import Tensor"
    },
    {
      "execution_count": 2,
      "code_cell_id": 13,
      "code": "class GoogLeNet(nn.Module):\n def __init__(\n self,\n num_classes: int = 1000,\n dropout: float = 0.2,\n dropout_aux: float = 0.7,\n ) -> None:\n super().__init__()\n conv_block = BasicConv2d\n inception_block = Inception\n inception_aux_block = InceptionAux\n\n self.conv1 = conv_block(3, 64, kernel_size=7, stride=2, padding=3)\n self.maxpool1 = nn.MaxPool2d(3, stride=2, ceil_mode=True)\n self.conv2 = conv_block(64, 64, kernel_size=1)\n self.conv3 = conv_block(64, 192, kernel_size=3, padding=1)\n self.maxpool2 = nn.MaxPool2d(3, stride=2, ceil_mode=True)\n\n self.inception3a = inception_block(192, 64, 96, 128, 16, 32, 32)\n self.inception3b = inception_block(256, 128, 128, 192, 32, 96, 64)\n self.maxpool3 = nn.MaxPool2d(3, stride=2, ceil_mode=True)\n\n self.inception4a = inception_block(480, 192, 96, 208, 16, 48, 64)\n self.inception4b = inception_block(512, 160, 112, 224, 24, 64, 64)\n self.inception4c = inception_block(512, 128, 128, 256, 24, 64, 64)\n self.inception4d = inception_block(512, 112, 144, 288, 32, 64, 64)\n self.inception4e = inception_block(528, 256, 160, 320, 32, 128, 128)\n self.maxpool4 = nn.MaxPool2d(2, stride=2, ceil_mode=True)\n\n self.inception5a = inception_block(832, 256, 160, 320, 32, 128, 128)\n self.inception5b = inception_block(832, 384, 192, 384, 48, 128, 128)\n\n self.aux1 = inception_aux_block(512, num_classes, dropout=dropout_aux)\n self.aux2 = inception_aux_block(528, num_classes, dropout=dropout_aux)\n\n self.avgpool = nn.AdaptiveAvgPool2d((1, 1))\n self.dropout = nn.Dropout(p=dropout)\n self.fc = nn.Linear(1024, num_classes)\n\n def forward(self, x: Tensor) -> Tuple[Tensor, Optional[Tensor], Optional[Tensor]]:\n\n x = self.conv1(x)\n\n x = self.maxpool1(x)\n\n x = self.conv2(x)\n\n x = self.conv3(x)\n\n x = self.maxpool2(x)\n\n x = self.inception3a(x)\n\n x = self.inception3b(x)\n\n x = self.maxpool3(x)\n\n x = self.inception4a(x)\n\n aux1 = self.aux1(x)\n\n x = self.inception4b(x)\n\n x = self.inception4c(x)\n\n x = self.inception4d(x)\n\n aux2 = self.aux2(x)\n\n x = self.inception4e(x)\n\n x = self.maxpool4(x)\n\n x = self.inception5a(x)\n\n x = self.inception5b(x)\n\n x = self.avgpool(x)\n\n x = torch.flatten(x, 1)\n\n x = self.dropout(x)\n x = self.fc(x)\n\n return x, aux2, aux1"
    },
    {
      "execution_count": 3,
      "code_cell_id": 14,
      "code": "class Inception(nn.Module):\n def __init__(\n self,\n in_channels: int,\n ch1x1: int,\n ch3x3red: int,\n ch3x3: int,\n ch5x5red: int,\n ch5x5: int,\n pool_proj: int,\n conv_block: Optional[Callable[..., nn.Module]] = None,\n ) -> None:\n super().__init__()\n if conv_block is None:\n conv_block = BasicConv2d\n self.branch1 = conv_block(in_channels, ch1x1, kernel_size=1)\n\n self.branch2 = nn.Sequential(\n conv_block(in_channels, ch3x3red, kernel_size=1), conv_block(ch3x3red, ch3x3, kernel_size=3, padding=1)\n )\n\n self.branch3 = nn.Sequential(\n conv_block(in_channels, ch5x5red, kernel_size=1),\n conv_block(ch5x5red, ch5x5, kernel_size=3, padding=1),\n )\n\n self.branch4 = nn.Sequential(\n nn.MaxPool2d(kernel_size=3, stride=1, padding=1, ceil_mode=True),\n conv_block(in_channels, pool_proj, kernel_size=1),\n )\n\n def forward(self, x: Tensor) -> List[Tensor]:\n branch1 = self.branch1(x)\n branch2 = self.branch2(x)\n branch3 = self.branch3(x)\n branch4 = self.branch4(x)\n\n outputs = [branch1, branch2, branch3, branch4]\n return outputs"
    },
    {
      "execution_count": 4,
      "code_cell_id": 15,
      "code": "class InceptionAux(nn.Module):\n def __init__(\n self,\n in_channels: int,\n num_classes: int,\n conv_block: Optional[Callable[..., nn.Module]] = None,\n dropout: float = 0.7,\n ) -> None:\n super().__init__()\n if conv_block is None:\n conv_block = BasicConv2d\n self.conv = conv_block(in_channels, 128, kernel_size=1)\n\n self.fc1 = nn.Linear(2048, 1024)\n self.fc2 = nn.Linear(1024, num_classes)\n self.dropout = nn.Dropout(p=dropout)\n\n def forward(self, x: Tensor) -> Tensor:\n\n x = F.adaptive_avg_pool2d(x, (4, 4))\n\n x = self.conv(x)\n\n x = torch.flatten(x, 1)\n\n x = F.relu(self.fc1(x), inplace=True)\n\n x = self.dropout(x)\n\n x = self.fc2(x)\n\n return x"
    },
    {
      "execution_count": 5,
      "code_cell_id": 16,
      "code": "class BasicConv2d(nn.Module):\n def __init__(self, in_channels: int, out_channels: int, kernel_size, stride=1, padding=0) -> None:\n super().__init__()\n self.conv = nn.Conv2d(in_channels, out_channels, bias=False, kernel_size=kernel_size ,stride=stride, padding=padding)\n self.bn = nn.BatchNorm2d(out_channels, eps=0.001)\n\n def forward(self, x: Tensor) -> Tensor:\n x = self.conv(x)\n x = self.bn(x)\n return F.relu(x, inplace=True)"
    },
    {
      "execution_count": 6,
      "code_cell_id": 17,
      "code": "url = \"https://download.pytorch.org/models/googlenet-1378be20.pth\"\nweights = torch.hub.load_state_dict_from_url(url, map_location='cpu')"
    },
    {
      "execution_count": 7,
      "code_cell_id": 18,
      "code": "torch_googlenet_re = GoogLeNet()\ntorch_googlenet_re.load_state_dict(weights)"
    },
    {
      "execution_count": 11,
      "code_cell_id": 22,
      "code": "import urllib\nurl, filename = (\"https://github.com/pytorch/hub/raw/master/images/dog.jpg\", \"dog.jpg\")\ntry: urllib.URLopener().retrieve(url, filename)\nexcept: urllib.request.urlretrieve(url, filename)\n\nfrom PIL import Image\ndog_image = Image.open(filename)\ndisplay(dog_image)"
    },
    {
      "execution_count": 16,
      "code_cell_id": 23,
      "code": "from torchvision import transforms\nfrom PIL import Image\n\npreprocess = transforms.Compose([\n transforms.Resize(256),\n transforms.CenterCrop(224),\n transforms.ToTensor(),\n transforms.Normalize(\n mean=[0.485, 0.456, 0.406],\n std=[0.229, 0.224, 0.225]\n)])\ntorch_img = Image.open(\"dog.jpg\")\ntorch_img = preprocess(dog_image)\ntorch_img = torch.unsqueeze(torch_img, 0)"
    },
    {
      "execution_count": 14,
      "code_cell_id": 28,
      "code": "torch_googlenet_re.eval()"
    }
  ],
  "target": {
    "code_cell_id": 34,
    "code": "torch_googlenet_re(torch_img)"
  }
}