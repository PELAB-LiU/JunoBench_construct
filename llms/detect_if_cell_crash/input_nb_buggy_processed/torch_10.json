{
  "executed": [
    {
      "execution_count": 1,
      "code_cell_id": 0,
      "code": "import torch\nimport torchvision\nimport torch.nn as nn\nimport torch.optim as optim\nimport torchvision.transforms as transforms\nimport matplotlib.pyplot as plt\nimport numpy as np"
    },
    {
      "execution_count": 2,
      "code_cell_id": 3,
      "code": "import os\nimport torch\nimport torchvision\nimport numpy as np\nfrom PIL import Image\nimport torch.nn as nn\nfrom torch.nn import ReLU\nimport torch.optim as optim\nimport torch.nn.functional as F\nimport matplotlib.pyplot as plt\nimport torchvision.transforms as transforms\nfrom torch.utils.data import Dataset,DataLoader\nfrom torch.nn import Conv2d,MaxPool2d,Flatten,Linear\n\ntrain_data_path = 'data_small/101/train'\ntest_data_path = 'data_small/101/val'\ntransform = transforms.Compose([\n transforms.Resize((227,227)),\n transforms.ToTensor(),\n])\n\ntrain_data=torchvision.datasets.ImageFolder(root = train_data_path,transform = transform)\ntest_data = torchvision.datasets.ImageFolder(root = test_data_path,transform = transform)\n\ntrain_dataloader = DataLoader(dataset = train_data,batch_size=64,shuffle=True,drop_last=False)\ntest_dataloader = DataLoader(dataset = test_data,batch_size=64,shuffle=True,drop_last=False)\n\nclass module(nn.Module):\n def __init__(self):\n super(module,self).__init__()\n self.conv1 = Conv2d(3,96,11,stride = 4)\n self.relu1 = ReLU()\n self.maxpool1 = MaxPool2d(3,stride = 2)\n self.conv2 = Conv2d(96,256,5,stride = 1,padding = 2)\n self.relu2 = ReLU()\n self.maxpool2 = MaxPool2d(3,stride = 2)\n self.conv3 = Conv2d(256,384,3,stride = 1,padding = 1)\n self.relu3 = ReLU()\n self.conv4 = Conv2d(384,256,3,stride = 1,padding = 1)\n self.relu4 = ReLU()\n self.conv5 = Conv2d(256,256,3,stride = 1,padding = 1)\n self.relu5 = ReLU()\n self.maxpool5 = MaxPool2d(3,stride = 2)\n self.flatten = Flatten()\n self.fc1 = Linear(6*6*256,4096)\n self.fc2 = Linear(4096,101)\n\n def forward(self,x):\n x = self.conv1(x)\n x = self.relu1(x)\n x = self.maxpool1(x)\n x = self.conv2(x)\n x = self.relu2(x)\n x = self.maxpool2(x)\n x = self.conv3(x)\n x = self.relu3(x)\n x = self.conv4(x)\n x = self.relu4(x)\n x = self.conv5(x)\n x = self.relu5(x)\n x = self.maxpool5(x)\n x = self.flatten(x)\n x = self.fc1(x)\n x = self.fc2(x)\n return x\n\nmodule = module()\nif torch.cuda.is_available():\n module = module.cuda()\n\nloss_fn = nn.CrossEntropyLoss()\nif torch.cuda.is_available():\n loss_fn = loss_fn.cuda()\n\nlearning_rate = 0.001\noptimizer = torch.optim.Adam(module.parameters(),lr = learning_rate)\n\ntotal_train_step = 0\ntotal_test_step = 0\nepoch = 2\n\nfor i in range(epoch):\n print('------第{}轮训练开始------'.format(i+1))\n\n module.train()\n for data in train_dataloader:\n imgs,targets = data\n if torch.cuda.is_available():\n imgs = imgs.cuda()\n targets = targets.cuda()\n outputs = module(imgs)\n loss = loss_fn(outputs,targets)\n\n optimizer.zero_grad()\n loss.backward()\n optimizer.step()\n\n total_train_step = total_train_step + 1\n if total_train_step % 100 ==0:\n print(\"训练次数：{}，LOSS：{}\".format(total_train_step,loss.item()))\n\n module.eval()\n total_test_loss = 0\n total_accuracy = 0\n with torch.no_grad():\n for data in test_dataloader:\n imgs,targets = data\n if torch.cuda.is_available():\n imgs = imgs.cuda()\n targets = targets.cuda()\n outputs = module(imgs)\n loss = loss_fn(outputs,targets)\n total_test_loss = total_test_loss + loss.item()\n accuracy = (outputs.argmax(1) == targets).sum()\n total_accuracy = total_accuracy + accuracy\n print('整体测试集LOSS:{}'.format(total_test_loss))\n print('正确率：{}'.format(total_accuracy/len(test_data)))\n total_test_step = total_test_step + 1"
    }
  ],
  "target": {
    "code_cell_id": 7,
    "code": "train_data_path = 'data_small/101/train'\ntrain_data=torchvision.datasets.ImageFolder(root = train_data_path,transform=transforms)\ntrain_dataloader = DataLoader(dataset = train_data,batch_size=64,shuffle=True,drop_last=False)\nfor data in train_dataloader:\n imgs,targets = data\n if torch.cuda.is_available():\n imgs = imgs.cuda()\n targets = targets.cuda()\n outputs = module(imgs)\n loss = loss_fn(outputs,targets)"
  }
}